#include <SFML/Graphics.hpp>
#include <vector>
#include <iostream>
#include <optional>
#include <list>
#include "sfml_view.h"
#include "enemy_agent.h"
#include "point_ball.h"

// Pelikentän koko
const int MAP_WIDTH = 30;
const int MAP_HEIGHT = 20;
const int TILE_SIZE = 32; // Säädä tämä sopivaksi näytöllesi

// Enumeraatio eri solmutyypeille
enum TileType {
    FLOOR = 0,
    WALL = 1,
    PLAYER = 2,
    ENEMY = 3,
    ENEMY2 = 4,  // Toinen vihollinen
    PATH = 5,
    OBSTACLE = 6,  // Väliaikainen este
    POINT_BALL = 7 // Pistepallo
};

// Väliaikainen este
struct TemporaryObstacle {
    int x;
    int y;
    float timeRemaining;

    TemporaryObstacle(int x, int y, float duration) : x(x), y(y), timeRemaining(duration) {}
};

// Funktio pelikentän luomiseen
std::vector<std::vector<int>> createMap() {
    // Alusta 30x20 kartta, jossa kaikki on ensin lattiaa (0)
    std::vector<std::vector<int>> map(MAP_HEIGHT, std::vector<int>(MAP_WIDTH, FLOOR));

    // Rivi 0 (ylin rivi) - täysi oranssi reuna
    for (int x = 0; x < MAP_WIDTH; x++) {
        map[0][x] = WALL;
    }

    // Rivit 1-18 - labyrintin sisäosa
    // Rivi 1
    for (int x : {0, 13, 29}) {
        map[1][x] = WALL;
    }

    // Rivi 2
    for (int x : {0, 1, 3, 4, 5, 7, 8, 9, 11, 13, 15, 16, 17, 18, 19, 21, 23, 24, 26, 28, 29}) {
        map[2][x] = WALL;
    }

    // Rivi 3
    for (int x : {0, 5, 11, 21, 26, 29}) {
        map[3][x] = WALL;
    }

    // Rivi 4
    for (int x : {0, 1, 2, 3, 5, 6, 7, 9, 11, 13, 14, 15, 16, 17, 19, 21, 22, 23, 24, 26, 27, 28, 29}) {
        map[4][x] = WALL;
    }

    // Rivi 5
    for (int x : {0, 3, 9, 19, 29}) {
        map[5][x] = WALL;
    }

    // Rivi 6
    for (int x : {0, 1, 3, 5, 6, 7, 9, 10, 11, 12, 13, 15, 16, 17, 19, 20, 21, 22, 23, 25, 27, 29}) {
        map[6][x] = WALL;
    }

    // Rivi 7
    for (int x : {0, 5, 13, 15, 17, 23, 25, 27, 29}) {
        map[7][x] = WALL;
    }

    // Rivi 8
    for (int x : {0, 2, 3, 5, 7, 8, 9, 10, 11, 13, 15, 17, 18, 19, 20, 21, 23, 25, 27, 29}) {
        map[8][x] = WALL;
    }

    // Rivi 9
    for (int x : {0, 2, 7, 11, 13, 25, 27, 29}) {
        map[9][x] = WALL;
    }

    // Rivi 10
    for (int x : {0, 2, 4, 5, 7, 9, 11, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 25, 27, 29}) {
        map[10][x] = WALL;
    }

    // Rivi 11
    for (int x : {0, 5, 9, 17, 19, 27, 29}) {
        map[11][x] = WALL;
    }

    // Rivi 12
    for (int x : {0, 1, 2, 3, 5, 7, 9, 10, 11, 12, 13, 15, 17, 19, 21, 22, 23, 24, 25, 27, 28, 29}) {
        map[12][x] = WALL;
    }

    // Rivi 13
    for (int x : {0, 1, 2, 3, 7, 13, 15, 21, 29}) {
        map[13][x] = WALL;
    }

    // Rivi 14
    for (int x : {0, 1, 2, 3, 5, 7, 8, 9, 10, 11, 13, 15, 16, 17, 18, 19, 21, 22, 23, 25, 26, 27, 29}) {
        map[14][x] = WALL;
    }

    // Rivi 15
    for (int x : {0, 5, 11, 15, 19, 23, 27, 29}) {
        map[15][x] = WALL;
    }

    // Rivi 16
    for (int x : {0, 2, 4, 5, 6, 7, 9, 11, 12, 13, 15, 17, 19, 21, 23, 25, 27, 29}) {
        map[16][x] = WALL;
    }

    // Rivi 17
    for (int x : {0, 2, 7, 9, 13, 17, 19, 21, 23, 25, 27, 29}) {
        map[17][x] = WALL;
    }

    // Rivi 18
    for (int x : {0, 4, 5, 9, 10, 11, 15, 17, 21, 25, 29}) {
        map[18][x] = WALL;
    }

    // Rivi 19 (alin rivi) - täysi oranssi reuna
    for (int x = 0; x < MAP_WIDTH; x++) {
        map[19][x] = WALL;
    }

    return map;
}

// Funktio, joka tarkistaa, onko este viholliselle läpäisemätön
bool isImpassable(int tileType) {
    return tileType == WALL || tileType == OBSTACLE;
}

// Funktio, joka puhdistaa kartan vihollisten haamujäljistä
void cleanGhosts(std::vector<std::vector<int>>& map, const Point& enemy1Pos, const Point& enemy2Pos, const Point& playerPos) {
    for (int y = 0; y < MAP_HEIGHT; y++) {
        for (int x = 0; x < MAP_WIDTH; x++) {
            // Tarkistetaan onko ruutu vihollisen jälki, joka ei ole kummankaan vihollisen nykyinen sijainti
            if ((map[y][x] == ENEMY && !(x == enemy1Pos.x && y == enemy1Pos.y) && !(x == playerPos.x && y == playerPos.y)) ||
                (map[y][x] == ENEMY2 && !(x == enemy2Pos.x && y == enemy2Pos.y) && !(x == playerPos.x && y == playerPos.y))) {
                // Kyseessä on "haamu", joten muutetaan se lattiaksi
                map[y][x] = FLOOR;
            }

            // Varmistetaan että vihollisten sijainnit ovat oikein merkitty
            if (x == enemy1Pos.x && y == enemy1Pos.y && map[y][x] != PLAYER && map[y][x] != ENEMY2) {
                map[y][x] = ENEMY;
            }
            else if (x == enemy2Pos.x && y == enemy2Pos.y && map[y][x] != PLAYER && map[y][x] != ENEMY) {
                map[y][x] = ENEMY2;
            }
        }
    }
}

// Tarkistetaan törmäävö pelaaja viholliseen
bool checkPlayerCollision(const Position& player, const Point& enemy1Pos, const Point& enemy2Pos) {
    // Tarkista törmäys kumpaankin viholliseen
    return (player.x == enemy1Pos.x && player.y == enemy1Pos.y) ||
        (player.x == enemy2Pos.x && player.y == enemy2Pos.y);
}

int main() {
    // Luo ikkuna käyttäen sf::Vector2u tyyppisiä arvoja
    sf::VideoMode mode;
    mode.size = sf::Vector2u(MAP_WIDTH * TILE_SIZE, MAP_HEIGHT * TILE_SIZE);
    sf::RenderWindow window(mode, "Pathfinding Game - Kaksi vihollista");
    window.setFramerateLimit(60);

    // Lataa tekstuurit
    sf::Texture floorTexture, wallTexture, playerTexture, enemyTexture, enemy2Texture, pathTexture, obstacleTexture, pointBallTexture;

    if (!floorTexture.loadFromFile("assets/floor.png") ||
        !wallTexture.loadFromFile("assets/wall2.png") ||
        !playerTexture.loadFromFile("assets/player2.png") ||
        !enemyTexture.loadFromFile("assets/enemy2.png") ||
        !pathTexture.loadFromFile("assets/path.png") ||
        !obstacleTexture.loadFromFile("assets/este.png") ||
        !pointBallTexture.loadFromFile("assets/piste.png")) {
        std::cerr << "Couldn't load textures!" << std::endl;
        return 1;
    }

    // Käytä samaa tekstuuria toiselle viholliselle mutta eri värisenä
    enemy2Texture = enemyTexture;

    // Luo pelikenttä
    auto map = createMap();

    // Pelaajan sijainti (jossakin lattiaruudussa)
    Position player = { 16, 7 }; // Keskellä labyrinttia
    map[player.y][player.x] = PLAYER;

    // Ensimmäinen vihollinen käyttää BASIC algoritmia (normaali A*)
    EnemyAgent enemy1(28, 15, EnemyAgent::BASIC); // Oikeassa alakulmassa
    map[enemy1.getPosition().y][enemy1.getPosition().x] = ENEMY;

    // Toinen vihollinen käyttää GREEDY algoritmia (ahne A*)
    EnemyAgent enemy2(3, 15, EnemyAgent::GREEDY); // Vasemmassa alakulmassa
    map[enemy2.getPosition().y][enemy2.getPosition().x] = ENEMY2;

    // Pistepallo - korjaa POINT_BALL_TILE vastaamaan POINT_BALL-arvoa
    PointBall pointBall(MAP_WIDTH, MAP_HEIGHT);
    // Aseta oikea POINT_BALL_TILE arvo
    pointBall.POINT_BALL_TILE = POINT_BALL;
    pointBall.initialize(map, player, enemy1.getPosition());
    pointBall.placeOnMap(map);

    // Näytä alkupisteet
    std::cout << "Score: 0" << std::endl;

    // Pelispritien luonti
    sf::Sprite floorSprite(floorTexture);
    sf::Sprite wallSprite(wallTexture);
    sf::Sprite playerSprite(playerTexture);
    sf::Sprite enemySprite(enemyTexture);
    sf::Sprite enemy2Sprite(enemy2Texture);
    enemy2Sprite.setColor(sf::Color(255, 150, 150)); // Muuta toisen vihollisen väriä hieman punaisemmaksi
    sf::Sprite pathSprite(pathTexture);
    sf::Sprite obstacleSprite(obstacleTexture);
    sf::Sprite pointBallSprite(pointBallTexture);

    // Vihollisten päivitysaika (päivitetään joka N:s ruutu)
    int enemyUpdateFrames = 15; // Päivitä viholliset joka 15. ruutu
    int frameCount = 0;

    // Pelaajan liikkumisen viive (liiallisen nopeuden estämiseksi)
    sf::Clock movementClock;
    const float movementDelay = 0.15f; // sekuntia

    // Väliaikaisen esteen pudottamisen viive
    sf::Clock obstacleClock;
    const float obstacleDelay = 10.0f; // sekuntia (10 sekuntia)
    bool canPlaceObstacle = true;

    // Muuttuja joka kertoo onko este jo käytössä
    bool obstacleActive = false;

    // Väliaikainen este
    TemporaryObstacle* currentObstacle = nullptr;
    const float obstacleDuration = 5.0f; // sekuntia

    // Onko peli käynnissä
    bool gameRunning = true;

    // Pääsilmukka
    sf::Clock deltaClock; // Ajanottokellon lisäys delta-ajan laskemiseksi
    while (window.isOpen()) {
        float deltaTime = deltaClock.restart().asSeconds();

        // Käsittele tapahtumat
        std::optional<sf::Event> optEvent = window.pollEvent();
        while (optEvent) {
            // Tarkista onko ikkuna suljettu
            if (optEvent->is<sf::Event::Closed>()) {
                window.close();
            }

            // Hae seuraava tapahtuma
            optEvent = window.pollEvent();
        }

        // Jos peli on päättynyt, älä käsittele pelimekaniikkaa
        if (!gameRunning) {
            continue;
        }

        // Käsittele pelaajan liikkuminen (nuolinäppäimet)
        if (movementClock.getElapsedTime().asSeconds() >= movementDelay) {
            bool moved = false;
            int oldX = player.x;
            int oldY = player.y;

            // Tarkista mitkä nuolinäppäimet ovat painettuina
            if (sf::Keyboard::isKeyPressed(sf::Keyboard::Key::Up)) {
                if (player.y > 0 && map[player.y - 1][player.x] != WALL && map[player.y - 1][player.x] != OBSTACLE) {
                    // Poista pelaaja vanhasta sijainnista
                    map[player.y][player.x] = FLOOR;
                    player.y--;
                    moved = true;
                }
            }
            else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Key::Down)) {
                if (player.y < MAP_HEIGHT - 1 && map[player.y + 1][player.x] != WALL && map[player.y + 1][player.x] != OBSTACLE) {
                    // Poista pelaaja vanhasta sijainnista
                    map[player.y][player.x] = FLOOR;
                    player.y++;
                    moved = true;
                }
            }
            else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Key::Left)) {
                if (player.x > 0 && map[player.y][player.x - 1] != WALL && map[player.y][player.x - 1] != OBSTACLE) {
                    // Poista pelaaja vanhasta sijainnista
                    map[player.y][player.x] = FLOOR;
                    player.x--;
                    moved = true;
                }
            }
            else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Key::Right)) {
                if (player.x < MAP_WIDTH - 1 && map[player.y][player.x + 1] != WALL && map[player.y][player.x + 1] != OBSTACLE) {
                    // Poista pelaaja vanhasta sijainnista
                    map[player.y][player.x] = FLOOR;
                    player.x++;
                    moved = true;
                }
            }

            // Käsittele väliaikaisen esteen pudottaminen (SPACE-näppäin)
            if (canPlaceObstacle && !obstacleActive && sf::Keyboard::isKeyPressed(sf::Keyboard::Key::Space)) {
                // Pudota este pelaajan nykyisestä sijainnista, jos siirryimme
                if (moved && oldX >= 0 && oldY >= 0 && map[oldY][oldX] == FLOOR) {
                    // Lisää väliaikainen este pelaajan entiseen sijaintiin
                    currentObstacle = new TemporaryObstacle(oldX, oldY, obstacleDuration);
                    map[oldY][oldX] = OBSTACLE;

                    // Merkataan este aktiiviseksi ja aloitetaan ajastin
                    obstacleActive = true;
                    canPlaceObstacle = false;
                    obstacleClock.restart();

                    // Pakota vihollisten reitin uudelleenlaskenta
                    Point playerPos = { player.x, player.y };
                    Point enemy1Pos = enemy1.getPosition();
                    Point enemy2Pos = enemy2.getPosition();

                    // Päivitä vihollisten sijainnit (huomioi että este on läpäisemätön)
                    enemy1.update(map, playerPos, isImpassable);
                    enemy2.update(map, playerPos, isImpassable);

                    // Varmista, että viholliset ovat edelleen kartalla
                    map[enemy1Pos.y][enemy1Pos.x] = ENEMY;
                    map[enemy2Pos.y][enemy2Pos.x] = ENEMY2;

                    // Puhdista kartta vihollisten haamuista
                    cleanGhosts(map, enemy1Pos, enemy2Pos, playerPos);
                }
            }

            // Päivitä pistepallon tila - käytä myös toisen vihollisen sijaintia
            Point enemy1Pos = enemy1.getPosition();
            Point enemy2Pos = enemy2.getPosition();
            // Jos pelaaja osuu pistepallon kohdalle, kerätään piste
            if (player.x == pointBall.getPosition().x && player.y == pointBall.getPosition().y) {
                // Lisää piste
                pointBall.collectPoint();
                // Etsi uusi sijainti pistepallolle
                pointBall.initialize(map, player, enemy1Pos);
                pointBall.placeOnMap(map);
            }

            if (moved) {
                // Aseta pelaaja uuteen sijaintiin
                map[player.y][player.x] = PLAYER;

                // Nollaa liikkumisajastin
                movementClock.restart();

                // Puhdista kartta vihollisten haamujäljistä
                Point playerPos = { player.x, player.y };
                cleanGhosts(map, enemy1Pos, enemy2Pos, playerPos);

                // Tarkista törmäävö pelaaja viholliseen
                if (checkPlayerCollision(player, enemy1Pos, enemy2Pos)) {
                    std::cout << "Game Over! Final Score: " << pointBall.getScore() << std::endl;
                    gameRunning = false;
                    window.close();
                    break;
                }
            }
        }

        // Päivitä esteiden pudottamisen viive
        if (!canPlaceObstacle && obstacleClock.getElapsedTime().asSeconds() >= obstacleDelay) {
            canPlaceObstacle = true;
        }

        // Päivitä väliaikainen este
        if (obstacleActive && currentObstacle != nullptr) {
            currentObstacle->timeRemaining -= deltaTime;

            if (currentObstacle->timeRemaining <= 0) {
                // Poista este, jos sen aika on loppunut
                if (map[currentObstacle->y][currentObstacle->x] == OBSTACLE) {
                    map[currentObstacle->y][currentObstacle->x] = FLOOR;

                    // Pakota vihollisten reitin uudelleenlaskenta
                    Point playerPos = { player.x, player.y };
                    enemy1.update(map, playerPos, isImpassable);
                    enemy2.update(map, playerPos, isImpassable);
                }

                // Poista este ja vapauta muisti
                delete currentObstacle;
                currentObstacle = nullptr;
                obstacleActive = false;
            }
        }

        // Päivitä viholliset tietyin väliajoin
        frameCount++;
        if (frameCount >= enemyUpdateFrames) {
            frameCount = 0;

            // Päivitä ensimmäinen vihollinen
            Point oldPos1 = enemy1.getPosition();
            if (map[oldPos1.y][oldPos1.x] == ENEMY) {
                map[oldPos1.y][oldPos1.x] = FLOOR;
            }

            // Päivitä toinen vihollinen
            Point oldPos2 = enemy2.getPosition();
            if (map[oldPos2.y][oldPos2.x] == ENEMY2) {
                map[oldPos2.y][oldPos2.x] = FLOOR;
            }

            // Päivitä vihollisten sijainnit
            Point playerPos = { player.x, player.y };
            enemy1.update(map, playerPos, isImpassable);
            enemy2.update(map, playerPos, isImpassable);

            // Aseta viholliset uusiin sijainteihin (vain jos niissä ei ole pelaajaa)
            Point newPos1 = enemy1.getPosition();
            if (map[newPos1.y][newPos1.x] != PLAYER) {
                map[newPos1.y][newPos1.x] = ENEMY;
            }

            Point newPos2 = enemy2.getPosition();
            if (map[newPos2.y][newPos2.x] != PLAYER) {
                map[newPos2.y][newPos2.x] = ENEMY2;
            }

            // Tarkista törmäävö vihollinen pelaajaan
            if (checkPlayerCollision(player, newPos1, newPos2)) {
                std::cout << "Game Over! Final Score: " << pointBall.getScore() << std::endl;
                gameRunning = false;
                window.close();
                break;
            }

            // Puhdista kartta vihollisten haamujäljistä
            cleanGhosts(map, newPos1, newPos2, playerPos);
        }

        // Tyhjennä ikkuna
        window.clear(sf::Color(50, 50, 50));

        // Piirrä pelikenttä
        for (int y = 0; y < MAP_HEIGHT; y++) {
            for (int x = 0; x < MAP_WIDTH; x++) {
                // Aseta spritelle oikea sijainti
                sf::Vector2f position(x * TILE_SIZE, y * TILE_SIZE);

                // Piirrä lattia tai seinä pohjalle
                if (map[y][x] == WALL) {
                    wallSprite.setPosition(position);
                    window.draw(wallSprite);
                }
                else {
                    floorSprite.setPosition(position);
                    window.draw(floorSprite);
                }

                // Tarkista onko tämä kohta polulla (kumman tahansa vihollisen)
                bool isOnPath1 = false;
                const auto& currentPath1 = enemy1.getCurrentPath();
                for (size_t i = 0; i < currentPath1.size(); i++) {
                    if (currentPath1[i].x == x && currentPath1[i].y == y &&
                        map[y][x] != WALL && map[y][x] != OBSTACLE) {
                        isOnPath1 = true;
                        break;
                    }
                }

                bool isOnPath2 = false;
                const auto& currentPath2 = enemy2.getCurrentPath();
                for (size_t i = 0; i < currentPath2.size(); i++) {
                    if (currentPath2[i].x == x && currentPath2[i].y == y &&
                        map[y][x] != WALL && map[y][x] != OBSTACLE) {
                        isOnPath2 = true;
                        break;
                    }
                }

                // Piirrä polku, jos kohta on polulla
                if (isOnPath1 || isOnPath2) {
                    sf::Color pathColor = sf::Color::White;

                    // Jos kohta on molempien vihollisten polulla, käytä eri väriä
                    if (isOnPath1 && isOnPath2) {
                        pathColor = sf::Color(255, 220, 220); // Vaaleanpunainen
                    }
                    else if (isOnPath2) {
                        pathColor = sf::Color(255, 240, 240); // Vaaleampi punainen
                    }

                    pathSprite.setColor(pathColor);
                    pathSprite.setPosition(position);
                    window.draw(pathSprite);
                    // Palauta normaali väri
                    pathSprite.setColor(sf::Color::White);
                }

                // Piirrä esteet, pistepallo, viholliset ja pelaaja
                switch (map[y][x]) {
                case OBSTACLE:
                    obstacleSprite.setPosition(position);
                    window.draw(obstacleSprite);
                    break;
                case POINT_BALL:
                    pointBallSprite.setPosition(position);
                    window.draw(pointBallSprite);
                    break;
                case ENEMY:
                    enemySprite.setPosition(position);
                    window.draw(enemySprite);
                    break;
                case ENEMY2:
                    enemy2Sprite.setPosition(position);
                    window.draw(enemy2Sprite);
                    break;
                case PLAYER:
                    playerSprite.setPosition(position);
                    window.draw(playerSprite);
                    break;
                }
            }
        }

        // Näytä ikkuna
        window.display();
    }

    // Siivoa muisti
    if (currentObstacle != nullptr) {
        delete currentObstacle;
    }

    return 0;
}